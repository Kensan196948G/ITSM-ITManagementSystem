# エージェント実装ガイド
## 各サブエージェント向け詳細実装仕様

### 目次
1. [ITSM-DevAPI 実装ガイド](#1-itsm-devapi-実装ガイド)
2. [ITSM-DevUI 実装ガイド](#2-itsm-devui-実装ガイド)
3. [ITSM-QA 実装ガイド](#3-itsm-qa-実装ガイド)
4. [ITSM-Tester 実装ガイド](#4-itsm-tester-実装ガイド)
5. [エージェント間連携仕様](#5-エージェント間連携仕様)
6. [共通開発ツール](#6-共通開発ツール)

---

## 1. ITSM-DevAPI 実装ガイド

### 1.1 責務と成果物
```yaml
Primary_Responsibilities:
  - FastAPI を使用したバックエンドAPI開発
  - SQLAlchemy を使用したデータベース設計・実装
  - ビジネスロジック実装
  - セキュリティ機能実装
  - API ドキュメント生成

Deliverables:
  - REST API エンドポイント
  - GraphQL スキーマ・リゾルバ
  - データベースマイグレーション
  - ユニットテスト
  - API ドキュメント (OpenAPI)
```

### 1.2 開発環境セットアップ
```bash
# 開発環境構築
cd backend/
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate    # Windows

# 依存関係インストール
pip install -r requirements.txt
pip install -r requirements-dev.txt

# 環境設定
cp .env.example .env
# .env ファイルを適切に編集

# データベース初期化
alembic upgrade head

# 開発サーバー起動
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### 1.3 ディレクトリ構造
```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI アプリケーション
│   ├── core/
│   │   ├── config.py          # 設定管理
│   │   ├── security.py        # セキュリティ機能
│   │   ├── database.py        # データベース接続
│   │   └── exceptions.py      # カスタム例外
│   ├── api/
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── router.py      # メインルーター
│   │   │   ├── auth.py        # 認証エンドポイント
│   │   │   ├── incidents.py   # インシデント管理
│   │   │   ├── problems.py    # 問題管理
│   │   │   ├── changes.py     # 変更管理
│   │   │   └── cmdb.py        # CMDB管理
│   │   └── graphql/
│   │       ├── schema.py      # GraphQL スキーマ
│   │       └── resolvers.py   # GraphQL リゾルバ
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base.py           # ベースモデル
│   │   ├── user.py          # ユーザーモデル
│   │   ├── incident.py      # インシデントモデル
│   │   └── ...              # その他のモデル
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── user.py          # ユーザースキーマ
│   │   ├── incident.py      # インシデントスキーマ
│   │   └── ...              # その他のスキーマ
│   ├── services/
│   │   ├── __init__.py
│   │   ├── auth_service.py   # 認証サービス
│   │   ├── incident_service.py
│   │   └── ...              # ビジネスロジック
│   └── utils/
│       ├── __init__.py
│       ├── validators.py     # バリデーション
│       └── helpers.py       # ヘルパー関数
├── alembic/                  # データベースマイグレーション
├── tests/
└── requirements.txt
```

### 1.4 実装例 - インシデント管理API
```python
# app/models/incident.py
from sqlalchemy import Column, String, Text, DateTime, Enum, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .base import BaseModel
import enum

class IncidentStatus(enum.Enum):
    NEW = "new"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    CLOSED = "closed"

class IncidentPriority(enum.Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class Incident(BaseModel):
    __tablename__ = "incidents"
    
    incident_number = Column(String(20), unique=True, nullable=False, index=True)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    status = Column(Enum(IncidentStatus), nullable=False, default=IncidentStatus.NEW, index=True)
    priority = Column(Enum(IncidentPriority), nullable=False, index=True)
    
    # 関係者
    reporter_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    assignee_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    team_id = Column(UUID(as_uuid=True), ForeignKey("teams.id"), nullable=True)
    
    # SLA
    response_due_at = Column(DateTime(timezone=True))
    resolution_due_at = Column(DateTime(timezone=True))
    responded_at = Column(DateTime(timezone=True))
    resolved_at = Column(DateTime(timezone=True))
    
    # リレーション
    reporter = relationship("User", foreign_keys=[reporter_id])
    assignee = relationship("User", foreign_keys=[assignee_id])
    team = relationship("Team")
    work_notes = relationship("WorkNote", back_populates="incident")
    attachments = relationship("Attachment", back_populates="incident")

# app/schemas/incident.py
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime
from enum import Enum

class IncidentStatus(str, Enum):
    NEW = "new"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    CLOSED = "closed"

class IncidentPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class IncidentBase(BaseModel):
    title: str = Field(..., min_length=5, max_length=200)
    description: Optional[str] = Field(None, max_length=10000)
    priority: IncidentPriority
    
    @validator('title')
    def validate_title(cls, v):
        if not v.strip():
            raise ValueError('Title cannot be empty')
        return v.strip()

class IncidentCreate(IncidentBase):
    category_id: Optional[str] = None
    affected_ci_ids: List[str] = []

class IncidentUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=5, max_length=200)
    description: Optional[str] = Field(None, max_length=10000)
    status: Optional[IncidentStatus] = None
    priority: Optional[IncidentPriority] = None
    assignee_id: Optional[str] = None
    work_notes: Optional[str] = None

class IncidentResponse(IncidentBase):
    id: str
    incident_number: str
    status: IncidentStatus
    reporter: dict
    assignee: Optional[dict] = None
    created_at: datetime
    updated_at: datetime
    sla: dict
    
    class Config:
        from_attributes = True

# app/services/incident_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from fastapi import HTTPException, status
from ..models.incident import Incident, IncidentStatus
from ..schemas.incident import IncidentCreate, IncidentUpdate
from ..core.security import get_current_user

class IncidentService:
    def __init__(self, db: Session):
        self.db = db
    
    async def create_incident(
        self, 
        incident_data: IncidentCreate, 
        reporter_id: str,
        tenant_id: str
    ) -> Incident:
        # インシデント番号生成
        incident_number = await self._generate_incident_number()
        
        # SLA計算
        sla_info = await self._calculate_sla(incident_data.priority)
        
        incident = Incident(
            tenant_id=tenant_id,
            incident_number=incident_number,
            title=incident_data.title,
            description=incident_data.description,
            priority=incident_data.priority,
            reporter_id=reporter_id,
            response_due_at=sla_info['response_due'],
            resolution_due_at=sla_info['resolution_due']
        )
        
        self.db.add(incident)
        self.db.commit()
        self.db.refresh(incident)
        
        # イベント発行
        await self._publish_event("incident.created", incident)
        
        return incident
    
    async def get_incidents(
        self,
        tenant_id: str,
        status: Optional[List[IncidentStatus]] = None,
        assignee_id: Optional[str] = None,
        limit: int = 20,
        offset: int = 0
    ) -> List[Incident]:
        query = self.db.query(Incident).filter(
            Incident.tenant_id == tenant_id,
            Incident.deleted_at.is_(None)
        )
        
        if status:
            query = query.filter(Incident.status.in_(status))
        
        if assignee_id:
            query = query.filter(Incident.assignee_id == assignee_id)
        
        return query.offset(offset).limit(limit).all()
    
    async def update_incident(
        self,
        incident_id: str,
        update_data: IncidentUpdate,
        user_id: str,
        tenant_id: str
    ) -> Incident:
        incident = self.db.query(Incident).filter(
            Incident.id == incident_id,
            Incident.tenant_id == tenant_id,
            Incident.deleted_at.is_(None)
        ).first()
        
        if not incident:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Incident not found"
            )
        
        # 更新権限チェック
        if not await self._can_update_incident(incident, user_id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Permission denied"
            )
        
        # フィールド更新
        for field, value in update_data.dict(exclude_unset=True).items():
            if field == "work_notes" and value:
                await self._add_work_note(incident.id, value, user_id)
            else:
                setattr(incident, field, value)
        
        incident.updated_by = user_id
        self.db.commit()
        self.db.refresh(incident)
        
        # イベント発行
        await self._publish_event("incident.updated", incident)
        
        return incident

# app/api/v1/incidents.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from ...core.database import get_db
from ...core.security import get_current_user
from ...models.user import User
from ...schemas.incident import IncidentCreate, IncidentUpdate, IncidentResponse
from ...services.incident_service import IncidentService

router = APIRouter(prefix="/incidents", tags=["incidents"])

@router.post("/", response_model=IncidentResponse, status_code=201)
async def create_incident(
    incident_data: IncidentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """新規インシデント作成"""
    service = IncidentService(db)
    incident = await service.create_incident(
        incident_data, 
        current_user.id, 
        current_user.tenant_id
    )
    return incident

@router.get("/", response_model=List[IncidentResponse])
async def get_incidents(
    status: Optional[List[str]] = Query(None),
    assignee_id: Optional[str] = Query(None),
    limit: int = Query(20, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """インシデント一覧取得"""
    service = IncidentService(db)
    incidents = await service.get_incidents(
        current_user.tenant_id,
        status=status,
        assignee_id=assignee_id,
        limit=limit,
        offset=offset
    )
    return incidents

@router.patch("/{incident_id}", response_model=IncidentResponse)
async def update_incident(
    incident_id: str,
    update_data: IncidentUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """インシデント更新"""
    service = IncidentService(db)
    incident = await service.update_incident(
        incident_id,
        update_data,
        current_user.id,
        current_user.tenant_id
    )
    return incident
```

### 1.5 セキュリティ実装
```python
# app/core/security.py
from datetime import datetime, timedelta
from typing import Optional
import jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer
from sqlalchemy.orm import Session
from .config import settings
from .database import get_db
from ..models.user import User

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    token: str = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(token.credentials, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except jwt.PyJWTError:
        raise credentials_exception
    
    user = db.query(User).filter(
        User.id == user_id,
        User.is_active == True,
        User.deleted_at.is_(None)
    ).first()
    
    if user is None:
        raise credentials_exception
    
    return user

def require_permission(permission: str):
    def permission_checker(user: User = Depends(get_current_user)):
        if not user.has_permission(permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission '{permission}' required"
            )
        return user
    return permission_checker
```

### 1.6 テスト実装
```python
# tests/test_incidents.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from app.main import app
from app.core.database import get_db
from tests.utils import create_test_user, create_test_incident

client = TestClient(app)

@pytest.fixture
def authorized_client(test_db: Session):
    user = create_test_user(test_db)
    token = create_access_token({"sub": str(user.id)})
    client.headers = {"Authorization": f"Bearer {token}"}
    return client

def test_create_incident(authorized_client):
    incident_data = {
        "title": "Test incident",
        "description": "Test description",
        "priority": "medium"
    }
    
    response = authorized_client.post("/api/v1/incidents/", json=incident_data)
    assert response.status_code == 201
    
    data = response.json()
    assert data["title"] == incident_data["title"]
    assert data["status"] == "new"
    assert "incident_number" in data

def test_get_incidents(authorized_client, test_db):
    # テストデータ作成
    create_test_incident(test_db)
    
    response = authorized_client.get("/api/v1/incidents/")
    assert response.status_code == 200
    
    data = response.json()
    assert isinstance(data, list)
    assert len(data) > 0

def test_update_incident(authorized_client, test_db):
    incident = create_test_incident(test_db)
    
    update_data = {
        "status": "in_progress",
        "work_notes": "Started working on this incident"
    }
    
    response = authorized_client.patch(
        f"/api/v1/incidents/{incident.id}",
        json=update_data
    )
    assert response.status_code == 200
    
    data = response.json()
    assert data["status"] == "in_progress"
```

---

## 2. ITSM-DevUI 実装ガイド

### 2.1 責務と成果物
```yaml
Primary_Responsibilities:
  - React + TypeScript を使用したフロントエンド開発
  - ユーザーインターフェース設計・実装
  - ユーザーエクスペリエンス最適化
  - レスポンシブデザイン実装
  - アクセシビリティ対応

Deliverables:
  - React コンポーネント
  - TypeScript 型定義
  - ページコンポーネント
  - 共通UIコンポーネント
  - E2Eテスト
```

### 2.2 開発環境セットアップ
```bash
# フロントエンド開発環境構築
cd frontend/
npm install

# 環境設定
cp .env.example .env.local
# .env.local ファイルを適切に編集

# 開発サーバー起動
npm run dev

# テスト実行
npm run test
npm run test:e2e

# ビルド
npm run build
```

### 2.3 プロジェクト構造
```
frontend/
├── src/
│   ├── components/           # 再利用可能コンポーネント
│   │   ├── common/
│   │   │   ├── Button/
│   │   │   ├── Modal/
│   │   │   ├── DataTable/
│   │   │   └── ErrorBoundary/
│   │   ├── layout/
│   │   │   ├── Header/
│   │   │   ├── Sidebar/
│   │   │   └── Layout/
│   │   └── forms/
│   │       ├── IncidentForm/
│   │       └── UserForm/
│   ├── pages/               # ページコンポーネント
│   │   ├── Dashboard/
│   │   ├── incidents/
│   │   │   ├── IncidentList/
│   │   │   ├── IncidentDetail/
│   │   │   └── CreateIncident/
│   │   ├── problems/
│   │   ├── changes/
│   │   └── users/
│   ├── hooks/               # カスタムフック
│   │   ├── useApi.ts
│   │   ├── useAuth.ts
│   │   └── useNotification.ts
│   ├── services/           # API呼び出し
│   │   ├── api.ts
│   │   ├── authService.ts
│   │   └── incidentService.ts
│   ├── store/              # Redux Store
│   │   ├── index.ts
│   │   ├── authSlice.ts
│   │   └── incidentSlice.ts
│   ├── types/              # TypeScript 型定義
│   │   ├── index.ts
│   │   ├── api.ts
│   │   └── user.ts
│   ├── utils/
│   │   ├── constants.ts
│   │   ├── formatters.ts
│   │   └── validators.ts
│   └── theme/
│       └── theme.ts
├── tests/
├── public/
└── package.json
```

### 2.4 実装例 - インシデント管理UI
```typescript
// src/types/incident.ts
export interface Incident {
  id: string;
  incident_number: string;
  title: string;
  description?: string;
  status: 'new' | 'assigned' | 'in_progress' | 'resolved' | 'closed';
  priority: 'low' | 'medium' | 'high' | 'critical';
  reporter: User;
  assignee?: User;
  team?: Team;
  created_at: string;
  updated_at: string;
  sla: {
    response_due: string;
    resolution_due: string;
    response_met: boolean;
    resolution_met?: boolean;
  };
}

export interface CreateIncidentData {
  title: string;
  description?: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  category_id?: string;
}

// src/services/incidentService.ts
import { api } from './api';
import { Incident, CreateIncidentData } from '../types/incident';

class IncidentService {
  async getIncidents(params?: {
    status?: string[];
    assignee_id?: string;
    limit?: number;
    offset?: number;
  }): Promise<Incident[]> {
    const response = await api.get('/incidents', { params });
    return response.data;
  }

  async createIncident(data: CreateIncidentData): Promise<Incident> {
    const response = await api.post('/incidents', data);
    return response.data;
  }

  async updateIncident(id: string, data: Partial<Incident>): Promise<Incident> {
    const response = await api.patch(`/incidents/${id}`, data);
    return response.data;
  }

  async getIncident(id: string): Promise<Incident> {
    const response = await api.get(`/incidents/${id}`);
    return response.data;
  }
}

export const incidentService = new IncidentService();

// src/components/incidents/IncidentList.tsx
import React, { useState, useEffect } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  IconButton,
  Tooltip,
  Box,
  Typography,
  TextField,
  MenuItem,
  Button,
  Toolbar
} from '@mui/material';
import {
  Edit as EditIcon,
  Visibility as ViewIcon,
  FilterList as FilterIcon
} from '@mui/icons-material';
import { useQuery } from '@tanstack/react-query';
import { incidentService } from '../../services/incidentService';
import { Incident } from '../../types/incident';
import { formatDateTime, getStatusColor, getPriorityColor } from '../../utils/formatters';

interface IncidentListProps {
  onEdit?: (incident: Incident) => void;
  onView?: (incident: Incident) => void;
}

const IncidentList: React.FC<IncidentListProps> = ({ onEdit, onView }) => {
  const [filters, setFilters] = useState({
    status: '',
    priority: '',
    search: ''
  });

  const {
    data: incidents = [],
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['incidents', filters],
    queryFn: () => incidentService.getIncidents({
      status: filters.status ? [filters.status] : undefined,
      // その他のフィルター処理
    }),
    refetchInterval: 30000 // 30秒ごとに更新
  });

  const handleFilterChange = (field: string) => (event: React.ChangeEvent<HTMLInputElement>) => {
    setFilters(prev => ({
      ...prev,
      [field]: event.target.value
    }));
  };

  if (isLoading) return <div>Loading incidents...</div>;
  if (error) return <div>Error loading incidents</div>;

  return (
    <Box>
      <Toolbar>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          インシデント一覧
        </Typography>
        <Button variant="contained" color="primary">
          新規作成
        </Button>
      </Toolbar>

      {/* フィルター */}
      <Box sx={{ p: 2, display: 'flex', gap: 2 }}>
        <TextField
          label="検索"
          value={filters.search}
          onChange={handleFilterChange('search')}
          size="small"
          sx={{ minWidth: 200 }}
        />
        <TextField
          label="ステータス"
          select
          value={filters.status}
          onChange={handleFilterChange('status')}
          size="small"
          sx={{ minWidth: 150 }}
        >
          <MenuItem value="">すべて</MenuItem>
          <MenuItem value="new">新規</MenuItem>
          <MenuItem value="assigned">割り当て済み</MenuItem>
          <MenuItem value="in_progress">対応中</MenuItem>
          <MenuItem value="resolved">解決済み</MenuItem>
          <MenuItem value="closed">完了</MenuItem>
        </TextField>
        <TextField
          label="優先度"
          select
          value={filters.priority}
          onChange={handleFilterChange('priority')}
          size="small"
          sx={{ minWidth: 120 }}
        >
          <MenuItem value="">すべて</MenuItem>
          <MenuItem value="low">低</MenuItem>
          <MenuItem value="medium">中</MenuItem>
          <MenuItem value="high">高</MenuItem>
          <MenuItem value="critical">緊急</MenuItem>
        </TextField>
      </Box>

      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>タイトル</TableCell>
              <TableCell>ステータス</TableCell>
              <TableCell>優先度</TableCell>
              <TableCell>担当者</TableCell>
              <TableCell>作成日時</TableCell>
              <TableCell>SLA</TableCell>
              <TableCell>操作</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {incidents.map((incident) => (
              <TableRow key={incident.id}>
                <TableCell>{incident.incident_number}</TableCell>
                <TableCell>
                  <Typography variant="body2" noWrap sx={{ maxWidth: 200 }}>
                    {incident.title}
                  </Typography>
                </TableCell>
                <TableCell>
                  <Chip
                    label={incident.status}
                    color={getStatusColor(incident.status)}
                    size="small"
                  />
                </TableCell>
                <TableCell>
                  <Chip
                    label={incident.priority}
                    color={getPriorityColor(incident.priority)}
                    size="small"
                  />
                </TableCell>
                <TableCell>
                  {incident.assignee?.name || '未割り当て'}
                </TableCell>
                <TableCell>
                  {formatDateTime(incident.created_at)}
                </TableCell>
                <TableCell>
                  <SLAIndicator sla={incident.sla} />
                </TableCell>
                <TableCell>
                  <Tooltip title="詳細表示">
                    <IconButton
                      size="small"
                      onClick={() => onView?.(incident)}
                    >
                      <ViewIcon />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="編集">
                    <IconButton
                      size="small"
                      onClick={() => onEdit?.(incident)}
                    >
                      <EditIcon />
                    </IconButton>
                  </Tooltip>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Box>
  );
};

// SLA状況表示コンポーネント
const SLAIndicator: React.FC<{ sla: Incident['sla'] }> = ({ sla }) => {
  const isResponseOverdue = !sla.response_met && new Date() > new Date(sla.response_due);
  const isResolutionOverdue = sla.resolution_met === false && new Date() > new Date(sla.resolution_due);

  if (isResponseOverdue || isResolutionOverdue) {
    return <Chip label="期限超過" color="error" size="small" />;
  }
  
  if (sla.response_met && sla.resolution_met) {
    return <Chip label="期限内" color="success" size="small" />;
  }
  
  return <Chip label="対応中" color="warning" size="small" />;
};

export default IncidentList;

// src/components/incidents/CreateIncidentForm.tsx
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  MenuItem,
  Box,
  Typography,
  Alert
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { incidentService } from '../../services/incidentService';
import { CreateIncidentData } from '../../types/incident';

const schema = yup.object({
  title: yup
    .string()
    .required('タイトルは必須です')
    .min(5, 'タイトルは5文字以上で入力してください')
    .max(200, 'タイトルは200文字以内で入力してください'),
  description: yup
    .string()
    .max(10000, '説明は10000文字以内で入力してください'),
  priority: yup
    .string()
    .required('優先度は必須です')
    .oneOf(['low', 'medium', 'high', 'critical'], '有効な優先度を選択してください')
});

interface CreateIncidentFormProps {
  open: boolean;
  onClose: () => void;
}

const CreateIncidentForm: React.FC<CreateIncidentFormProps> = ({ open, onClose }) => {
  const queryClient = useQueryClient();
  const [submitError, setSubmitError] = useState<string | null>(null);

  const {
    control,
    handleSubmit,
    reset,
    formState: { errors, isValid }
  } = useForm<CreateIncidentData>({
    resolver: yupResolver(schema),
    defaultValues: {
      title: '',
      description: '',
      priority: 'medium'
    }
  });

  const createMutation = useMutation({
    mutationFn: incidentService.createIncident,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
      reset();
      onClose();
      setSubmitError(null);
    },
    onError: (error: any) => {
      setSubmitError(error.response?.data?.error?.message || 'エラーが発生しました');
    }
  });

  const onSubmit = (data: CreateIncidentData) => {
    setSubmitError(null);
    createMutation.mutate(data);
  };

  const handleClose = () => {
    reset();
    setSubmitError(null);
    onClose();
  };

  return (
    <Dialog open={open} onClose={handleClose} maxWidth="md" fullWidth>
      <form onSubmit={handleSubmit(onSubmit)}>
        <DialogTitle>新規インシデント作成</DialogTitle>
        <DialogContent>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
            {submitError && (
              <Alert severity="error">{submitError}</Alert>
            )}

            <Controller
              name="title"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  label="タイトル"
                  fullWidth
                  required
                  error={!!errors.title}
                  helperText={errors.title?.message}
                />
              )}
            />

            <Controller
              name="description"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  label="説明"
                  fullWidth
                  multiline
                  rows={4}
                  error={!!errors.description}
                  helperText={errors.description?.message}
                />
              )}
            />

            <Controller
              name="priority"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  label="優先度"
                  select
                  fullWidth
                  required
                  error={!!errors.priority}
                  helperText={errors.priority?.message}
                >
                  <MenuItem value="low">低</MenuItem>
                  <MenuItem value="medium">中</MenuItem>
                  <MenuItem value="high">高</MenuItem>
                  <MenuItem value="critical">緊急</MenuItem>
                </TextField>
              )}
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>キャンセル</Button>
          <Button
            type="submit"
            variant="contained"
            disabled={!isValid || createMutation.isPending}
          >
            {createMutation.isPending ? '作成中...' : '作成'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};

export default CreateIncidentForm;
```

---

## 3. ITSM-QA 実装ガイド

### 3.1 責務と成果物
```yaml
Primary_Responsibilities:
  - テスト戦略・計画策定
  - テストケース設計・作成
  -品質基準定義
  - テスト実行・結果分析
  -品質メトリクス管理

Deliverables:
  - テスト計画書
  - テストケース
  - 品質レポート
  - テスト実行結果
  - 品質メトリクス
```

### 3.2 テスト戦略
```yaml
Test_Strategy:
  Test_Levels:
    Unit_Tests:
      Coverage_Target: "> 80%"
      Framework: "Jest, Pytest"
      Responsibility: "開発者"
    
    Integration_Tests:
      Focus: "API統合, データベース連携"
      Framework: "Supertest, TestContainers"
      Responsibility: "DevAPI, DevUI"
    
    System_Tests:
      Focus: "エンドツーエンド機能"
      Framework: "Playwright"
      Responsibility: "Tester"
    
    Performance_Tests:
      Focus: "レスポンス時間, スループット"
      Framework: "k6, Artillery"
      Responsibility: "Tester"
    
    Security_Tests:
      Focus: "脆弱性, 認証・認可"
      Framework: "OWASP ZAP, Nuclei"
      Responsibility: "Tester"

Test_Types:
  Functional_Tests:
    - インシデント管理機能
    - 問題管理機能
    - 変更管理機能
    - ユーザー管理機能
    - 認証・認可機能
  
  Non_Functional_Tests:
    - パフォーマンステスト
    - セキュリティテスト
    - ユーザビリティテスト
    - アクセシビリティテスト
    - 互換性テスト
```

### 3.3 テストケース例
```yaml
# インシデント管理機能テストケース
Test_Suite: "Incident Management"

Test_Cases:
  TC_INC_001:
    Title: "新規インシデント作成"
    Priority: "High"
    Preconditions:
      - ユーザーがログインしている
      - インシデント作成権限を持っている
    Steps:
      1: "インシデント一覧ページにアクセス"
      2: "「新規作成」ボタンをクリック"
      3: "必須項目を入力（タイトル、説明、優先度）"
      4: "「作成」ボタンをクリック"
    Expected_Results:
      - インシデントが正常に作成される
      - インシデント番号が自動採番される
      - 作成者が記録される
      - SLA期限が自動計算される
    Test_Data:
      title: "メールサーバー接続エラー"
      description: "朝9時からメール送受信ができない"
      priority: "high"

  TC_INC_002:
    Title: "インシデント一覧表示"
    Priority: "Medium"
    Steps:
      1: "インシデント一覧ページにアクセス"
      2: "表示内容を確認"
    Expected_Results:
      - インシデント一覧が表示される
      - 各項目（ID、タイトル、ステータス等）が正しく表示される
      - ページネーションが動作する
      - フィルター機能が動作する

  TC_INC_003:
    Title: "インシデント更新"
    Priority: "High"
    Preconditions:
      - 更新対象のインシデントが存在する
      - ユーザーが更新権限を持っている
    Steps:
      1: "インシデント詳細ページにアクセス"
      2: "「編集」ボタンをクリック"
      3: "ステータスを「対応中」に変更"
      4: "作業メモを追加"
      5: "「更新」ボタンをクリック"
    Expected_Results:
      - インシデントが正常に更新される
      - ステータスが変更される
      - 作業メモが追加される
      - 更新日時が記録される
      - 履歴が作成される

# セキュリティテストケース
Security_Test_Cases:
  TC_SEC_001:
    Title: "認証なしでのAPIアクセス"
    Type: "Negative Test"
    Steps:
      1: "認証トークンなしでAPI呼び出し"
    Expected_Results:
      - HTTP 401 Unauthorized が返される
      - エラーメッセージが適切に返される

  TC_SEC_002:
    Title: "SQLインジェクション攻撃"
    Type: "Security Test"
    Steps:
      1: "検索フィールドにSQLインジェクション文字列を入力"
      2: "検索実行"
    Test_Data:
      injection_string: "'; DROP TABLE incidents; --"
    Expected_Results:
      - SQLインジェクションが阻止される
      - エラーログが記録される
      - システムが正常に動作し続ける

  TC_SEC_003:
    Title: "権限外データアクセス"
    Type: "Authorization Test"
    Steps:
      1: "一般ユーザーで管理者APIにアクセス"
    Expected_Results:
      - HTTP 403 Forbidden が返される
      - 不正アクセスがログに記録される
```

### 3.4 品質メトリクス
```yaml
Quality_Metrics:
  Code_Quality:
    - Code Coverage: "> 80%"
    - Cyclomatic Complexity: "< 10"
    - Technical Debt Ratio: "< 5%"
    - Duplication Rate: "< 3%"
  
  Functional_Quality:
    - Test Pass Rate: "> 95%"
    - Defect Density: "< 2 defects/KLOC"
    - Customer Satisfaction: "> 4.0/5.0"
  
  Performance_Quality:
    - API Response Time: "< 200ms (p95)"
    - Page Load Time: "< 3s"
    - Concurrent Users: "> 1000"
    - Availability: "> 99.9%"
  
  Security_Quality:
    - Vulnerability Count: "0 Critical, 0 High"
    - Security Test Coverage: "> 90%"
    - Penetration Test Score: "> 8/10"
```

---

## 4. ITSM-Tester 実装ガイド

### 4.1 責務と成果物
```yaml
Primary_Responsibilities:
  - 自動テスト実装・実行
  - パフォーマンステスト実行
  - セキュリティテスト実行
  - テスト結果分析・レポート
  - CI/CD パイプライン統合

Deliverables:
  - 自動テストスイート
  - パフォーマンステスト結果
  - セキュリティスキャン結果
  - テスト実行レポート
  - CI/CD 設定ファイル
```

### 4.2 E2Eテスト実装
```typescript
// tests/e2e/incidents.spec.ts
import { test, expect } from '@playwright/test';

test.describe('インシデント管理', () => {
  test.beforeEach(async ({ page }) => {
    // ログイン処理
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await page.waitForURL('/dashboard');
  });

  test('新規インシデント作成フロー', async ({ page }) => {
    // インシデント一覧ページに移動
    await page.goto('/incidents');
    await expect(page.locator('h1')).toContainText('インシデント一覧');

    // 新規作成ボタンをクリック
    await page.click('button:text("新規作成")');
    
    // モーダルが表示されることを確認
    await expect(page.locator('[role="dialog"]')).toBeVisible();
    await expect(page.locator('h2')).toContainText('新規インシデント作成');

    // フォーム入力
    await page.fill('input[name="title"]', 'テストインシデント');
    await page.fill('textarea[name="description"]', 'テスト用の説明文');
    await page.selectOption('select[name="priority"]', 'high');

    // 作成ボタンをクリック
    await page.click('button:text("作成")');

    // 成功メッセージまたはリダイレクトを確認
    await expect(page.locator('.success-message')).toBeVisible();
    
    // インシデント一覧に新しいインシデントが表示されることを確認
    await expect(page.locator('table tbody tr').first()).toContainText('テストインシデント');
  });

  test('インシデント検索・フィルター機能', async ({ page }) => {
    await page.goto('/incidents');

    // 検索機能テスト
    await page.fill('input[placeholder="検索"]', 'メール');
    await page.press('input[placeholder="検索"]', 'Enter');
    
    // 検索結果の確認
    const rows = page.locator('table tbody tr');
    await expect(rows).toHaveCount({ min: 1 });
    await expect(rows.first()).toContainText('メール');

    // ステータスフィルターテスト
    await page.selectOption('select[name="status"]', 'in_progress');
    
    // フィルター結果の確認
    const statusChips = page.locator('table tbody tr .status-chip');
    const count = await statusChips.count();
    for (let i = 0; i < count; i++) {
      await expect(statusChips.nth(i)).toContainText('対応中');
    }
  });

  test('インシデント詳細・更新フロー', async ({ page }) => {
    await page.goto('/incidents');
    
    // 最初のインシデントの詳細ボタンをクリック
    await page.click('table tbody tr:first-child button[title="詳細表示"]');
    
    // 詳細ページに移動することを確認
    await expect(page).toHaveURL(/\/incidents\/[^\/]+$/);
    await expect(page.locator('h1')).toContainText('インシデント詳細');

    // 編集ボタンをクリック
    await page.click('button:text("編集")');
    
    // ステータス更新
    await page.selectOption('select[name="status"]', 'resolved');
    
    // 作業メモ追加
    await page.fill('textarea[name="work_notes"]', '問題を解決しました');
    
    // 更新ボタンをクリック
    await page.click('button:text("更新")');
    
    // 更新が反映されることを確認
    await expect(page.locator('.status-chip')).toContainText('解決済み');
    await expect(page.locator('.work-note').last()).toContainText('問題を解決しました');
  });

  test('SLAアラート表示', async ({ page }) => {
    await page.goto('/incidents');
    
    // SLA期限が近いまたは超過しているインシデントを確認
    const slaWarning = page.locator('.sla-warning');
    if (await slaWarning.count() > 0) {
      await expect(slaWarning.first()).toBeVisible();
      await expect(slaWarning.first()).toHaveClass(/warning|error/);
    }
  });
});

// パフォーマンステスト
test.describe('パフォーマンス', () => {
  test('ページ読み込み時間', async ({ page }) => {
    const startTime = Date.now();
    await page.goto('/incidents');
    await page.waitForLoadState('networkidle');
    const loadTime = Date.now() - startTime;
    
    // 3秒以内に読み込み完了することを確認
    expect(loadTime).toBeLessThan(3000);
  });

  test('大量データでの表示性能', async ({ page }) => {
    // 大量データがある状態での表示テスト
    await page.goto('/incidents?limit=1000');
    
    const startTime = Date.now();
    await page.waitForSelector('table tbody tr');
    const renderTime = Date.now() - startTime;
    
    // 5秒以内にレンダリング完了することを確認
    expect(renderTime).toBeLessThan(5000);
  });
});
```

### 4.3 API統合テスト
```python
# tests/integration/test_api_integration.py
import pytest
import httpx
from typing import Dict, Any

@pytest.fixture
async def authenticated_client():
    async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
        # 認証
        login_response = await client.post("/api/v1/auth/login", json={
            "email": "test@example.com",
            "password": "password123"
        })
        token = login_response.json()["access_token"]
        
        client.headers.update({"Authorization": f"Bearer {token}"})
        yield client

class TestIncidentAPI:
    async def test_incident_lifecycle(self, authenticated_client: httpx.AsyncClient):
        """インシデントの完全なライフサイクルテスト"""
        
        # 1. インシデント作成
        create_data = {
            "title": "統合テスト用インシデント",
            "description": "APIテスト用の説明",
            "priority": "medium"
        }
        
        create_response = await authenticated_client.post(
            "/api/v1/incidents/", 
            json=create_data
        )
        assert create_response.status_code == 201
        
        incident = create_response.json()
        incident_id = incident["id"]
        assert incident["title"] == create_data["title"]
        assert incident["status"] == "new"
        
        # 2. インシデント取得
        get_response = await authenticated_client.get(f"/api/v1/incidents/{incident_id}")
        assert get_response.status_code == 200
        
        retrieved_incident = get_response.json()
        assert retrieved_incident["id"] == incident_id
        assert retrieved_incident["title"] == create_data["title"]
        
        # 3. インシデント更新
        update_data = {
            "status": "in_progress",
            "work_notes": "テスト作業を開始しました"
        }
        
        update_response = await authenticated_client.patch(
            f"/api/v1/incidents/{incident_id}",
            json=update_data
        )
        assert update_response.status_code == 200
        
        updated_incident = update_response.json()
        assert updated_incident["status"] == "in_progress"
        
        # 4. 履歴確認
        history_response = await authenticated_client.get(
            f"/api/v1/incidents/{incident_id}/history"
        )
        assert history_response.status_code == 200
        
        history = history_response.json()["data"]
        assert len(history) > 0
        assert any(h["action"] == "status_changed" for h in history)
        
        # 5. インシデント削除（論理削除）
        delete_response = await authenticated_client.delete(
            f"/api/v1/incidents/{incident_id}"
        )
        assert delete_response.status_code == 204
        
        # 削除後の取得で404が返ることを確認
        get_deleted_response = await authenticated_client.get(
            f"/api/v1/incidents/{incident_id}"
        )
        assert get_deleted_response.status_code == 404

    async def test_incident_search_and_filter(self, authenticated_client: httpx.AsyncClient):
        """インシデント検索・フィルター機能テスト"""
        
        # テストデータ作成
        test_incidents = [
            {"title": "メールサーバーエラー", "priority": "high", "status": "new"},
            {"title": "プリンターエラー", "priority": "low", "status": "assigned"},
            {"title": "ネットワーク障害", "priority": "critical", "status": "in_progress"}
        ]
        
        created_incidents = []
        for incident_data in test_incidents:
            response = await authenticated_client.post(
                "/api/v1/incidents/",
                json=incident_data
            )
            assert response.status_code == 201
            created_incidents.append(response.json())
        
        # ステータスフィルターテスト
        filter_response = await authenticated_client.get(
            "/api/v1/incidents/?status=new&status=assigned"
        )
        assert filter_response.status_code == 200
        
        filtered_incidents = filter_response.json()["data"]
        for incident in filtered_incidents:
            assert incident["status"] in ["new", "assigned"]
        
        # 優先度フィルターテスト
        priority_response = await authenticated_client.get(
            "/api/v1/incidents/?priority=high&priority=critical"
        )
        assert priority_response.status_code == 200
        
        priority_incidents = priority_response.json()["data"]
        for incident in priority_incidents:
            assert incident["priority"] in ["high", "critical"]

class TestAuthenticationAPI:
    async def test_authentication_flow(self):
        """認証フローの統合テスト"""
        async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
            
            # 1. 無効な認証情報でログイン
            invalid_login = await client.post("/api/v1/auth/login", json={
                "email": "invalid@example.com",
                "password": "wrongpassword"
            })
            assert invalid_login.status_code == 401
            
            # 2. 有効な認証情報でログイン
            valid_login = await client.post("/api/v1/auth/login", json={
                "email": "test@example.com",
                "password": "password123"
            })
            assert valid_login.status_code == 200
            
            token_data = valid_login.json()
            assert "access_token" in token_data
            assert "refresh_token" in token_data
            
            # 3. トークンを使用してプロファイル取得
            access_token = token_data["access_token"]
            profile_response = await client.get(
                "/api/v1/auth/profile",
                headers={"Authorization": f"Bearer {access_token}"}
            )
            assert profile_response.status_code == 200
            
            profile = profile_response.json()
            assert "id" in profile
            assert "email" in profile
            
            # 4. リフレッシュトークンを使用してトークン更新
            refresh_response = await client.post(
                "/api/v1/auth/refresh",
                json={"refresh_token": token_data["refresh_token"]}
            )
            assert refresh_response.status_code == 200
            
            new_token_data = refresh_response.json()
            assert "access_token" in new_token_data
            assert new_token_data["access_token"] != access_token
```

### 4.4 パフォーマンステスト
```javascript
// tests/performance/api_load_test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

export let errorRate = new Rate('errors');

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 100ユーザーまでランプアップ
    { duration: '5m', target: 100 }, // 100ユーザーで5分間維持
    { duration: '2m', target: 200 }, // 200ユーザーまでランプアップ
    { duration: '5m', target: 200 }, // 200ユーザーで5分間維持
    { duration: '2m', target: 0 },   // ランプダウン
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95%のリクエストが500ms以内
    http_req_failed: ['rate<0.1'],    // エラー率が10%未満
  },
};

const BASE_URL = 'http://localhost:8000/api/v1';
let authToken;

export function setup() {
  // 認証トークン取得
  const loginResponse = http.post(`${BASE_URL}/auth/login`, JSON.stringify({
    email: 'test@example.com',
    password: 'password123'
  }), {
    headers: { 'Content-Type': 'application/json' }
  });
  
  check(loginResponse, {
    'login successful': (r) => r.status === 200,
  });
  
  return { token: loginResponse.json('access_token') };
}

export default function(data) {
  const headers = {
    'Authorization': `Bearer ${data.token}`,
    'Content-Type': 'application/json'
  };

  // インシデント一覧取得
  let response = http.get(`${BASE_URL}/incidents`, { headers });
  
  check(response, {
    'incidents list status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  }) || errorRate.add(1);

  // インシデント作成
  const createData = {
    title: `Load test incident ${Math.random().toString(36).substr(2, 9)}`,
    description: 'Performance test incident',
    priority: 'medium'
  };

  response = http.post(`${BASE_URL}/incidents/`, JSON.stringify(createData), { headers });
  
  check(response, {
    'incident creation status is 201': (r) => r.status === 201,
    'creation response time < 1s': (r) => r.timings.duration < 1000,
  }) || errorRate.add(1);

  if (response.status === 201) {
    const incidentId = response.json('id');
    
    // インシデント詳細取得
    response = http.get(`${BASE_URL}/incidents/${incidentId}`, { headers });
    
    check(response, {
      'incident detail status is 200': (r) => r.status === 200,
    }) || errorRate.add(1);
  }

  sleep(1);
}

export function teardown(data) {
  // テスト終了後のクリーンアップ処理
}
```

### 4.5 セキュリティテスト
```python
# tests/security/test_security_vulnerabilities.py
import pytest
import httpx
from typing import List

class TestSecurityVulnerabilities:
    
    @pytest.fixture
    async def client(self):
        async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
            yield client
    
    async def test_sql_injection_protection(self, client: httpx.AsyncClient):
        """SQLインジェクション攻撃からの保護テスト"""
        
        # 認証
        login_response = await client.post("/api/v1/auth/login", json={
            "email": "test@example.com",
            "password": "password123"
        })
        token = login_response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # SQLインジェクション試行
        injection_payloads = [
            "'; DROP TABLE incidents; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO incidents (title) VALUES ('hacked'); --"
        ]
        
        for payload in injection_payloads:
            response = await client.get(
                f"/api/v1/incidents/?search={payload}",
                headers=headers
            )
            
            # SQLインジェクションが成功していないことを確認
            assert response.status_code in [200, 400]  # 正常またはバリデーションエラー
            
            # エラーメッセージにSQL情報が含まれていないことを確認
            if response.status_code == 400:
                error_msg = response.json().get("error", {}).get("message", "")
                assert "sql" not in error_msg.lower()
                assert "database" not in error_msg.lower()
    
    async def test_xss_protection(self, client: httpx.AsyncClient):
        """XSS攻撃からの保護テスト"""
        
        # 認証
        login_response = await client.post("/api/v1/auth/login", json={
            "email": "test@example.com",
            "password": "password123"
        })
        token = login_response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # XSSペイロード
        xss_payloads = [
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "javascript:alert('xss')",
            "<svg onload=alert('xss')>"
        ]
        
        for payload in xss_payloads:
            # インシデント作成でXSSペイロードを送信
            response = await client.post("/api/v1/incidents/", json={
                "title": f"Test {payload}",
                "description": f"Description with {payload}",
                "priority": "medium"
            }, headers=headers)
            
            if response.status_code == 201:
                incident = response.json()
                
                # タイトルと説明からスクリプトタグが除去されていることを確認
                assert "<script>" not in incident["title"]
                assert "<img" not in incident["title"]
                assert "javascript:" not in incident["title"]
                assert "<script>" not in incident.get("description", "")
    
    async def test_authentication_bypass(self, client: httpx.AsyncClient):
        """認証バイパス攻撃への対策テスト"""
        
        # 認証なしでのAPIアクセス
        protected_endpoints = [
            "/api/v1/incidents/",
            "/api/v1/problems/",
            "/api/v1/changes/",
            "/api/v1/users/profile"
        ]
        
        for endpoint in protected_endpoints:
            response = await client.get(endpoint)
            assert response.status_code == 401
        
        # 無効なトークンでのアクセス
        invalid_tokens = [
            "invalid_token",
            "Bearer invalid_token",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature"
        ]
        
        for token in invalid_tokens:
            headers = {"Authorization": f"Bearer {token}"}
            response = await client.get("/api/v1/incidents/", headers=headers)
            assert response.status_code == 401
    
    async def test_authorization_enforcement(self, client: httpx.AsyncClient):
        """認可制御の実装テスト"""
        
        # 一般ユーザーでログイン
        user_login = await client.post("/api/v1/auth/login", json={
            "email": "user@example.com",
            "password": "password123"
        })
        user_token = user_login.json()["access_token"]
        user_headers = {"Authorization": f"Bearer {user_token}"}
        
        # 管理者専用エンドポイントへのアクセス試行
        admin_endpoints = [
            "/api/v1/admin/users/",
            "/api/v1/admin/settings/",
            "/api/v1/admin/audit-logs/"
        ]
        
        for endpoint in admin_endpoints:
            response = await client.get(endpoint, headers=user_headers)
            assert response.status_code == 403
    
    async def test_rate_limiting(self, client: httpx.AsyncClient):
        """レート制限の実装テスト"""
        
        # 認証
        login_response = await client.post("/api/v1/auth/login", json={
            "email": "test@example.com",
            "password": "password123"
        })
        token = login_response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # 大量のリクエストを送信
        responses = []
        for i in range(100):  # 100回リクエスト
            response = await client.get("/api/v1/incidents/", headers=headers)
            responses.append(response.status_code)
        
        # レート制限が発動していることを確認
        rate_limited_count = responses.count(429)
        assert rate_limited_count > 0, "Rate limiting not working"
    
    async def test_input_validation(self, client: httpx.AsyncClient):
        """入力値検証のテスト"""
        
        # 認証
        login_response = await client.post("/api/v1/auth/login", json={
            "email": "test@example.com",
            "password": "password123"
        })
        token = login_response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # 不正な入力値
        invalid_inputs = [
            {"title": "", "priority": "medium"},  # 空のタイトル
            {"title": "a" * 300, "priority": "medium"},  # 長すぎるタイトル
            {"title": "Valid title", "priority": "invalid"},  # 無効な優先度
            {"title": "Valid title", "priority": "medium", "assignee_id": "invalid-uuid"}  # 無効なUUID
        ]
        
        for invalid_input in invalid_inputs:
            response = await client.post(
                "/api/v1/incidents/",
                json=invalid_input,
                headers=headers
            )
            assert response.status_code == 422  # Validation error
            
            error_response = response.json()
            assert "error" in error_response
            assert "details" in error_response["error"]
```

---

## 5. エージェント間連携仕様

### 5.1 タスク管理フォーマット
```yaml
# .claude-flow/tasks/task_template.yaml
Task:
  id: "task_${timestamp}_${agent}"
  type: "development|testing|review|deployment"
  title: "タスクのタイトル"
  description: "詳細な説明"
  assignee: "ITSM-DevAPI|ITSM-DevUI|ITSM-QA|ITSM-Tester"
  status: "pending|in_progress|completed|blocked"
  priority: 1-5  # 1=最高, 5=最低
  
  dependencies:
    - task_id: "依存するタスクID"
      type: "blocks|requires"
  
  deliverables:
    - path: "ファイルパス"
      type: "code|test|documentation"
      description: "成果物の説明"
  
  acceptance_criteria:
    - "受入条件1"
    - "受入条件2"
  
  metadata:
    estimated_hours: 8
    actual_hours: 0
    start_date: "2024-01-15T09:00:00+09:00"
    due_date: "2024-01-17T17:00:00+09:00"
    created_at: "2024-01-15T08:00:00+09:00"
    updated_at: "2024-01-15T08:00:00+09:00"
```

### 5.2 コードレビューフォーマット
```yaml
# .claude-flow/reviews/review_template.yaml
CodeReview:
  id: "review_${timestamp}"
  pull_request_id: "PR番号またはID"
  reviewer: "ITSM-CTO"
  author: "ITSM-DevAPI|ITSM-DevUI"
  status: "pending|approved|changes_requested|rejected"
  
  files_reviewed:
    - path: "app/api/v1/incidents.py"
      status: "approved|changes_requested"
      comments:
        - line: 45
          type: "suggestion|issue|question"
          message: "コメント内容"
          severity: "low|medium|high|critical"
  
  overall_comments:
    - "全体的なフィードバック"
  
  security_checklist:
    - item: "入力値検証が実装されている"
      status: "pass|fail|na"
    - item: "認証・認可が適切に実装されている"
      status: "pass|fail|na"
  
  quality_metrics:
    code_coverage: "85%"
    complexity_score: "7.2"
    duplication_rate: "2.1%"
  
  decision: "approve|request_changes|reject"
  decision_reason: "判定理由"
  
  created_at: "2024-01-15T10:00:00+09:00"
  completed_at: "2024-01-15T11:30:00+09:00"
```

### 5.3 テスト結果フォーマット
```yaml
# .claude-flow/test-results/test_result_template.yaml
TestResult:
  id: "test_${timestamp}"
  executor: "ITSM-Tester"
  test_suite: "unit|integration|e2e|performance|security"
  status: "passed|failed|error|skipped"
  
  summary:
    total_tests: 150
    passed: 145
    failed: 3
    skipped: 2
    error: 0
    
  execution_time:
    start: "2024-01-15T14:00:00+09:00"
    end: "2024-01-15T14:15:00+09:00"
    duration_seconds: 900
  
  test_cases:
    - id: "TC_INC_001"
      name: "新規インシデント作成"
      status: "passed"
      duration_ms: 1200
      
    - id: "TC_INC_002"
      name: "インシデント更新"
      status: "failed"
      duration_ms: 800
      error_message: "Assertion error: Expected status 'in_progress', got 'new'"
      stack_trace: "..."
  
  coverage:
    line_coverage: "87.5%"
    branch_coverage: "82.3%"
    function_coverage: "95.2%"
  
  performance_metrics:
    avg_response_time: "125ms"
    p95_response_time: "250ms"
    max_response_time: "1200ms"
    requests_per_second: 150
  
  artifacts:
    - type: "screenshot"
      path: "test-results/screenshots/incident_creation.png"
    - type: "log"
      path: "test-results/logs/test_execution.log"
    - type: "report"
      path: "test-results/reports/html_report.html"
```

---

## 6. 共通開発ツール

### 6.1 開発環境統一
```yaml
Development_Environment:
  Operating_System: "Ubuntu 22.04 LTS"
  
  Languages:
    Python: "3.11"
    Node.js: "18.x LTS"
    TypeScript: "5.0"
  
  IDEs:
    Primary: "Visual Studio Code"
    Extensions:
      - Python
      - TypeScript
      - ESLint
      - Prettier
      - GitLens
      - Docker
      - Kubernetes
  
  Version_Control:
    System: "Git"
    Platform: "GitHub"
    Branch_Strategy: "GitFlow"
    
  Package_Managers:
    Python: "pip + poetry"
    Node.js: "npm"
    
  Database_Tools:
    Client: "pgAdmin 4"
    CLI: "psql"
    Migration: "Alembic"
```

### 6.2 CI/CD設定
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test-backend:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: itsm_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt -r requirements-test.txt
      
      - name: Run tests
        run: |
          cd backend
          pytest tests/ --cov=app --cov-report=xml
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: backend/coverage.xml

  test-frontend:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        run: |
          cd frontend
          npm ci
      
      - name: Run tests
        run: |
          cd frontend
          npm run test -- --coverage
      
      - name: Build
        run: |
          cd frontend
          npm run build

  security-scan:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  deploy:
    needs: [test-backend, test-frontend, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to staging
        run: |
          # デプロイメントスクリプト実行
          echo "Deploying to staging environment"
```

### 6.3 品質チェック設定
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/psf/black
    rev: 23.1.0
    hooks:
      - id: black
        language_version: python3.11
        files: ^backend/
  
  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        files: ^backend/
  
  - repo: https://github.com/pycqa/flake8
    rev: 6.0.0
    hooks:
      - id: flake8
        files: ^backend/
  
  - repo: https://github.com/pre-commit/mirrors-eslint
    rev: v8.36.0
    hooks:
      - id: eslint
        files: ^frontend/src/.*\.(js|jsx|ts|tsx)$
        additional_dependencies:
          - eslint@8.36.0
          - "@typescript-eslint/parser@5.55.0"
  
  - repo: https://github.com/pre-commit/mirrors-prettier
    rev: v3.0.0-alpha.6
    hooks:
      - id: prettier
        files: ^frontend/src/.*\.(js|jsx|ts|tsx|json|css|md)$
```

### 6.4 監視・ログ設定
```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'itsm-backend'
    static_configs:
      - targets: ['localhost:8000']
    metrics_path: '/metrics'
    
  - job_name: 'itsm-frontend'
    static_configs:
      - targets: ['localhost:3000']
    
  - job_name: 'postgres'
    static_configs:
      - targets: ['localhost:9187']

# monitoring/grafana-dashboard.json
{
  "dashboard": {
    "title": "ITSM System Monitoring",
    "panels": [
      {
        "title": "API Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "title": "Active Incidents",
        "type": "stat",
        "targets": [
          {
            "expr": "count(incidents{status!=\"closed\"})",
            "legendFormat": "Active Incidents"
          }
        ]
      }
    ]
  }
}
```

---

## 結論

このエージェント実装ガイドにより、各サブエージェント（DevAPI、DevUI、QA、Tester）は以下を実現できます：

### 実装の成功要因
1. **明確な責務分担**: 各エージェントの役割と成果物が明確
2. **標準化されたプロセス**: 共通のツールとワークフロー
3. **品質保証**: 自動化されたテストと品質チェック
4. **効率的な連携**: 構造化されたタスク管理と情報共有
5. **継続的改善**: メトリクスベースの品質向上

### 期待される成果
- **開発効率**: 自動化により50%の効率向上
- **品質向上**: 統合テストにより90%以上の品質達成
- **セキュリティ**: 包括的なセキュリティテストによる脆弱性0件
- **保守性**: 標準化されたコードによる保守コスト30%削減

各エージェントは、この実装ガイドに従って開発を進めることで、世界クラスのITSMシステムを構築できます。